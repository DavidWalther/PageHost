const { Logging } = require('../../../../../modules/logging.js');
const OpenIdConnectClient = require('../../../../../modules/oAuth2/OpenIdConnectClient.js');
const { DataCache2 } = require('../../../../../database2/DataCache/DataCache.js');
const crypto = require('crypto');
const { EndpointLogic } = require('../../../../EndpointLogic.js');
const AccessTokenService = require('../../../../../modules/oAuth2/AccessTokenService.js');

const GOOGLE_ENDPOINT_WELLKNOWN = 'https://accounts.google.com/.well-known/openid-configuration';

class CodeExchangeEndpoint extends EndpointLogic {
  constructor() {
    super();
    this.environment = null;
    this.requestObject = null;
    this.responseObject = null;
  }
  get envVarAuthUrl() {
    return this.environment.AUTH_OIDC_AUTH_URL;
  }

  get redirectUri() {
    const LOCATION = 'CodeExchangeEndpoint.get redirectUri';
    let requestObjectAdressParameters = {
      protocol: this.requestObject.protocol,
      secure: this.requestObject.secure,
      hostname: this.requestObject.hostname,
      host: this.requestObject.get('host'),
      port: this.requestObject.port,
      pathname: this.requestObject.path,
      query: this.requestObject.query,
    }

    Logging.debugMessage({
      severity: 'FINE',
      message: `Request Object Address Parameters: ${JSON.stringify(requestObjectAdressParameters)}`,
      location: LOCATION
    });

    if (this.envVarAuthUrl) {
      Logging.debugMessage({
        severity: 'DEBUG',
        message: `AUTH_OIDC_REDIRECT_URI is set: ${this.envVarAuthUrl}`,
        location: LOCATION
      });
      return this.envVarAuthUrl;
    }

    //let redirectUri = `${this.requestObject.protocol}://${this.requestObject.hostname}`+ (this.environment.PORT ? `:${this.environment.PORT}` : '');
    let redirectUri = `${this.requestObject.protocol}://${this.requestObject.get('host')}`;
    Logging.debugMessage({
      severity: 'DEBUG',
      message: `Redirect URI: ${redirectUri}`,
      location: LOCATION
    });
    return redirectUri;
  }

  async execute() {
    const LOCATION = 'CodeExchangeEndpoint.execute';
    // Restrict access to login if not allowed
    const allowedActions = this.environment.APPLICATION_ACTIVE_ACTIONS || '[]';
    let allowed = [];
    try { allowed = JSON.parse(allowedActions).map(a => a.toLowerCase()); } catch (e) {}
    // Only require 'login' to be present for code exchange
    if (!allowed.includes('login')) {
      Logging.debugMessage({ severity: 'WARNING', message: 'Login not allowed by environment', location: LOCATION });
      this.responseObject.status(403).json({ error: 'Login not allowed' });
      return;
    }

    Logging.debugMessage({ severity: 'INFO', message: `Executing code exchange`, location: LOCATION });

    const REDIRECT_URI = `${this.requestObject.protocol}://${this.requestObject.get('host')}`;
    const { state, auth_code, code_verifier } = this.requestObject.body;

    if (!auth_code) {
      this.responseObject.status(400).json({ error: 'Missing auth_code' });
      Logging.debugMessage({ severity: 'INFO', message: `Missing auth_code`, location: LOCATION });
      return;
    }
    if (!state) {
      this.responseObject.status(400).json({ error: 'Missing auth_state' });
      Logging.debugMessage({ severity: 'INFO', message: `Missing auth-state`, location: LOCATION });
      return;
    }

    // ======= Validate state - Start ======
    // the state-value should have been generated by the server and stored in cache before
    const PREFIX_FOR_SHORT_TERM_CACHE = 'short-term';
    const auth_state_cache_key = `${PREFIX_FOR_SHORT_TERM_CACHE}-auth-state-${state}`;
    const cache = new DataCache2(this.environment);

    const isStateValid = await cache.get(auth_state_cache_key);
    if (!isStateValid) {
      this.responseObject.status(400).json({ error: 'Invalid or expired state' });
      Logging.debugMessage({ severity: 'INFO', message: 'Invalid or expired state', location: LOCATION });
      return;
    }

    await cache.del(auth_state_cache_key);
    Logging.debugMessage({ severity: 'INFO', message: 'State validated and removed from cache', location: LOCATION });

    if (!code_verifier) {
      this.responseObject.status(400).json({ error: 'Invalid code' });
      Logging.debugMessage({ severity: 'INFO', message: `Missing code verifier`, location: LOCATION });
      return;
    }
    // ======= Validate state - End ======

    // ====== Check if the auth_code is already used - Start ======
    /**
     * Save the auth_code in the cache to prevent replay attacks.
     * The Cache stores 'used-auth-codes.*'-keys for 20 minutes.
     */
    let auth_code_cache_key = PREFIX_FOR_SHORT_TERM_CACHE + '-used-auth-code-' + auth_code; // generate a unique cache key for the auth_code
    let ShortTermCacheKeyGenerator = await cache.get(auth_code_cache_key); // try to get the auth_code from the cache
    if ( ShortTermCacheKeyGenerator ) {
      // If the auth_code was actually found in the cache, it means it was already used
      this.responseObject.status(401).json({ error: 'Authentication code already used' });
      Logging.debugMessage({ severity: 'INFO', message: `Authentication code already used`, location: LOCATION });
      return;
    }
    await cache.set(auth_code_cache_key, true);
    // ====== Check if the auth_code is already used - End =======


    const oidcClient = new OpenIdConnectClient()
      .setRedirectUri(this.redirectUri)
      .setClientId(this.environment.GOOGLE_CLIENT_ID)
      .setClientSecret(this.environment.GOOGLE_CLIENT_SECRET)
      .setWellKnownEndpoint(GOOGLE_ENDPOINT_WELLKNOWN)
      .setCodeVerifier(code_verifier); // Set the code verifier for PKCE


    await oidcClient.exchangeAuthorizationCode(auth_code)
    .then(tokenResponse => {
      const [tokenHeader, tokenPayloadStr] = tokenResponse.id_token.split('.').map(part => Buffer.from(part, 'base64').toString());
      let tokenPayload = JSON.parse(tokenPayloadStr);
      /**
       * The user checks and create on of the bearer token will eventually be moved to a separate module.
       */

      let accessTokenService = new AccessTokenService();
      accessTokenService.setEnvironment(this.environment);

      if(!accessTokenService.isUserValid(tokenPayload)) {
        this.responseObject.status(401).json({ error: 'No new users allowed' });
        Logging.debugMessage({ severity: 'INFO', message: `No new users allowed`, location: LOCATION });
        return;
      }

      // extract the relevant information from the token response
      // relevant: first_name, last_name, picture, display_name, email

      let scopes = accessTokenService.getUserScopes(tokenPayload);
      accessTokenService.createBearer(tokenPayload)
      .then( bearerToken => {

          Logging.debugMessage({ severity: 'INFO', message: `Bearer token created for scope ${scopes}`, location: LOCATION });
          let user = {
            provider: 'google',
            first_name: tokenPayload.given_name,
            last_name: tokenPayload.family_name,
            picture: tokenPayload.picture,
            display_name: tokenPayload.name,
            email: tokenPayload.email
          };
          const auth_response = {
            authenticationResult: {
              user,
              access: {
                access_token: bearerToken,
                scopes
              }
            }
          };

          // send the response to the client
          this.responseObject.json(auth_response);
        });
    })
    .catch(error => {
      Logging.debugMessage({ severity: 'INFO', message: `Error during token exchange: ${error}`, location: LOCATION });
      this.responseObject.status(400).json({ error: 'Bad Request' });
    });
    Logging.debugMessage({ severity: 'INFO', message: `Code exchange completed`, location: LOCATION });
    return this.responseObject;
  }
}

module.exports = CodeExchangeEndpoint;

const { Logging } = require('../../../../modules/logging');
const OpenIdConnectClient = require('../../../../modules/oAuth2/OpenIdConnectClient');
const { DataCache2 } = require('../../../../database2/DataCache/DataCache.js');
const crypto = require('crypto');

const GOOGLE_ENDPOINT_WELLKNOWN = 'https://accounts.google.com/.well-known/openid-configuration';

class CodeExchangeEndpoint {
  constructor() {
    this.environment = null;
    this.requestObject = null;
    this.responseObject = null;
  }

  setEnvironment(environment) {
    this.environment = environment;
    return this;
  }

  setRequestObject(requestObject) {
    this.requestObject = requestObject;
    return this;
  }

  setResponseObject(responseObject) {
    this.responseObject = responseObject;
    return this;
  }

  async execute() {
    const LOCATION = 'CodeExchangeEndpoint.execute';
    Logging.debugMessage({ severity: 'INFO', message: `Executing code exchange`, location: LOCATION });

    const HOST = this.environment.HOST || `${this.requestObject.protocol}://${this.requestObject.get('host')}`;
    const { state, auth_code, code_verifier } = this.requestObject.body;

    if (!auth_code) {
      this.responseObject.status(400).json({ error: 'Missing auth_code' });
      Logging.debugMessage({ severity: 'INFO', message: `Missing auth_code`, location: LOCATION });
      return;
    }
    if (!state) {
      this.responseObject.status(400).json({ error: 'Missing auth_state' });
      Logging.debugMessage({ severity: 'INFO', message: `Missing auth-state`, location: LOCATION });
      return;
    }

    // ======= Validate state - Start ======
    // the state-value should have been generated by the server and stored in cache before
    const PREFIX_FOR_SHORT_TERM_CACHE = 'short-term';
    const auth_state_cache_key = `${PREFIX_FOR_SHORT_TERM_CACHE}-auth-state-${state}`;
    const cache = new DataCache2(this.environment);

    const isStateValid = await cache.get(auth_state_cache_key);
    if (!isStateValid) {
      this.responseObject.status(400).json({ error: 'Invalid or expired state' });
      Logging.debugMessage({ severity: 'INFO', message: 'Invalid or expired state', location: LOCATION });
      return;
    }

    await cache.del(auth_state_cache_key);
    Logging.debugMessage({ severity: 'INFO', message: 'State validated and removed from cache', location: LOCATION });

    if (!code_verifier) {
      this.responseObject.status(400).json({ error: 'Invalid code' });
      Logging.debugMessage({ severity: 'INFO', message: `Missing code verifier`, location: LOCATION });
      return;
    }
    // ======= Validate state - End ======

    // ====== Check if the auth_code is already used - Start ======
    /**
     * Save the auth_code in the cache to prevent replay attacks.
     * The Cache stores 'used-auth-codes.*'-keys for 20 minutes.
     */
    let auth_code_cache_key = PREFIX_FOR_SHORT_TERM_CACHE + '-used-auth-code-' + auth_code; // generate a unique cache key for the auth_code
    let ShortTermCacheKeyGenerator = await cache.get(auth_code_cache_key); // try to get the auth_code from the cache
    if ( ShortTermCacheKeyGenerator ) {
      // If the auth_code was actually found in the cache, it means it was already used
      this.responseObject.status(401).json({ error: 'Authentication code already used' });
      Logging.debugMessage({ severity: 'INFO', message: `Authentication code already used`, location: LOCATION });
      return;
    }
    await cache.set(auth_code_cache_key, true);
    // ====== Check if the auth_code is already used - End =======


    const oidcClient = new OpenIdConnectClient().setRedirectUri(HOST)
      .setClientId(this.environment.GOOGLE_CLIENT_ID)
      .setClientSecret(this.environment.GOOGLE_CLIENT_SECRET)
      .setWellKnownEndpoint(GOOGLE_ENDPOINT_WELLKNOWN)
      .setCodeVerifier(code_verifier); // Set the code verifier for PKCE


    await oidcClient.exchangeAuthorizationCode(auth_code)
    .then(tokenResponse => {
      const [tokenHeader, tokenPayload] = tokenResponse.id_token.split('.').map(part => Buffer.from(part, 'base64').toString());
      const randomToken = crypto.randomBytes(128).toString('hex');

      const response = {
        server_token: randomToken,
        providerResponse: {
          providedInfo: tokenResponse,
          tokenPayload: JSON.parse(tokenPayload)
        }
      };

      this.responseObject.json(response);
    })
    .catch(error => {
      Logging.debugMessage({ severity: 'INFO', message: `Error during token exchange: ${error}`, location: LOCATION });
      this.responseObject.status(400).json({ error: 'Bad Request' });
    });
    Logging.debugMessage({ severity: 'INFO', message: `Code exchange completed`, location: LOCATION });
    return this.responseObject;
  }
}

module.exports = CodeExchangeEndpoint;
